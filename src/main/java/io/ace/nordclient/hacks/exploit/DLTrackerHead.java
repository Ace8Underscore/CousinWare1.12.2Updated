package io.ace.nordclient.hacks.exploit;

import io.ace.nordclient.CousinWare;
import io.ace.nordclient.command.Command;
import io.ace.nordclient.event.PacketEvent;
import io.ace.nordclient.hacks.Hack;
import io.ace.nordclient.utilz.Setting;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.server.SPacketBlockChange;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.util.text.TextFormatting;
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener;

public class DLTrackerHead extends Hack {

    Setting xGoal;
    Setting zGoal;
    Setting step;
    Setting amountPerTick;
    Setting loadChunks;
    Setting ignore;
    Setting latency;
    Setting antiPacket;
    Setting debug;

    private long startTime = -1;
    int x = 0, z = 0;

    boolean pX = false, nX = false, pZ = false, nZ = false;

    public DLTrackerHead() {
        super("DLTrackerHead", Category.EXPLOIT, -1);
        CousinWare.INSTANCE.settingsManager.rSetting(xGoal = new Setting("XGoal", this, 3000000, 0, 30000000, true, "DLTrackerHeadXGoal", true));
        CousinWare.INSTANCE.settingsManager.rSetting(zGoal = new Setting("ZGoal", this, 3000000, 0, 30000000, true, "DLTrackerHeadZGoal", true));

        CousinWare.INSTANCE.settingsManager.rSetting(step = new Setting("BlockSkip", this, 100, 0, 200, true, "DLTrackerHeadStep", true));
        CousinWare.INSTANCE.settingsManager.rSetting(amountPerTick = new Setting("PacketsPetTick", this, 9, 0, 10, true, "DLTrackerHeadAmountPerTick", true));
        CousinWare.INSTANCE.settingsManager.rSetting(loadChunks = new Setting("LoadedChunks", this, true, "DLTrackerHeadLoadedChunks", true));
        CousinWare.INSTANCE.settingsManager.rSetting(ignore = new Setting("Ignore", this, true, "DLTrackerHeadIgnore", true));
        CousinWare.INSTANCE.settingsManager.rSetting(latency = new Setting("Latency", this, true, "DLTrackerHeadLatency", true));
        CousinWare.INSTANCE.settingsManager.rSetting(antiPacket = new Setting("AntiPacket", this, true, "DLTrackerHeadAntiPacket", true));
        CousinWare.INSTANCE.settingsManager.rSetting(debug = new Setting("Debug", this, false, "DLTrackerHeadDebug", true));

    }

    public void onEnable() {
        Command.sendClientSideMessage("Starting Search On Highways");
        startTime = System.currentTimeMillis();
        x = 0;
        z = 0;
        pX = false;
        pZ = false;
        nZ = false;
        nX = false;
    }

    @Listener
    public void onUpdate(PacketEvent.Send event) {
        if (event.getPacket() instanceof CPacketPlayer && antiPacket.getValBoolean()) { // stopping constant movement packets sent from the client to the server to let us scan faster
            event.setCanceled(true);
        }
    }

    @Listener
    public void onUpdate(PacketEvent.Receive event) {
        if(event.getPacket() instanceof SPacketBlockChange){
            SPacketBlockChange packetIn = (SPacketBlockChange) event.getPacket();
            if(ignore.getValBoolean() && mc.world.isBlockLoaded(packetIn.getBlockPosition(),false))
                return;
            ChunkPos chunkPos = new ChunkPos(packetIn.getBlockPosition());
            if(mc.player.getDistanceSq(packetIn.getBlockPosition())>72) {
                if (loadChunks.getValBoolean()) {
                    mc.world.doPreChunk(chunkPos.x, chunkPos.z, true);
                    mc.world.markBlockRangeForRenderUpdate(chunkPos.x << 4, 0, chunkPos.z << 4, (chunkPos.x << 4) + 15, 256, (chunkPos.z << 4) + 15);
                }
            }
            if(!loadChunks.getValBoolean() && mc.player.getDistanceSq(packetIn.getBlockPosition())>500*500)
                event.setCanceled(true);
            //here you can start a new tracker and or send some info to the remote host
            Command.sendClientSideMessage(TextFormatting.RED +"[DL]: "+TextFormatting.RESET +
                    packetIn.getBlockPosition().toString() + " -> " +packetIn.getBlockState().getBlock().getLocalizedName());


            if(latency.getValBoolean() && startTime!=-1){
                Command.sendClientSideMessage("Latency = "+ (System.currentTimeMillis()-startTime) +" ms");
                startTime=-1;
            }

        }
    }

    public void onUpdate() {
        if (mc.player.connection == null || mc.world == null)
            return;
        for (int i = 0; i < amountPerTick.getValInt(); i++) {
            int goal = 3000000;
            if (x >= xGoal.getValInt()) {
                pX = true;
                resetPostion();
            }
            if (x <= -xGoal.getValInt()) {
                nX = true;
                resetPostion();
            }
            if (z >= zGoal.getValInt()) {
                pZ = true;
                resetPostion();
            }
            if (z <= -zGoal.getValInt()) {
                nZ = true;
                resetPostion();
            }
            if (!pX) x += step.getValInt();
            else if (!nX) x += -step.getValInt();
            else if (!pZ) z += step.getValInt();
            else if (!nZ) z += -step.getValInt();
            else resetFinder();

            Command.sendClientSideMessage(x + " " + z);

            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, new BlockPos(x, 0, z), EnumFacing.UP));

        }
    }

    private void resetPostion() {
        x = 0;
        z  = 0;
        Command.sendClientSideMessage("Resetting to 0 0");
    }

    private void resetFinder() {
        x = 0;
        z = 0;
        pX = false;
        nX = false;
        pZ = false;
        nZ = false;
        Command.sendClientSideMessage("Restarting Finder");
    }

    @Override
    public String getHudInfo() {
        return x + " " + z;
    }


}
