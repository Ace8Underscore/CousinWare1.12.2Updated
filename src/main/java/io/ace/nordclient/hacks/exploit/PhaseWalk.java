package io.ace.nordclient.hacks.exploit;

import io.ace.nordclient.CousinWare;
import io.ace.nordclient.hacks.Hack;
import io.ace.nordclient.utilz.MathUtil;
import io.ace.nordclient.utilz.PlayerUtil;
import io.ace.nordclient.utilz.Setting;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketPlayer;

public class PhaseWalk extends Hack {

    Setting fallPacket;
    Setting instantWalk;
    Setting instantWalkSpeed;
    Setting fastPhase;
    Setting phaseSpeed;
    Setting phaseCheck;
    Setting downOnShift;
    Setting upOnJump;
    Setting stopMotion;
    Setting stopMotionDelay;
    int delay = 0;

    public PhaseWalk() {
        super("PhaseWalk", Category.EXPLOIT, 10788093);
        CousinWare.INSTANCE.settingsManager.rSetting(fallPacket = new Setting("FallPacket", this, true, "PhaseWalkFallPacket", true));
        CousinWare.INSTANCE.settingsManager.rSetting(instantWalk = new Setting("InstantWalk", this, true, "PhaseWalkInstantWalk", true));
        CousinWare.INSTANCE.settingsManager.rSetting(instantWalkSpeed = new Setting("InstantWalkSpeed", this, .18, .1, .19, false, "PhaseWalkInstantWalk", instantWalk.getValBoolean()));
        CousinWare.INSTANCE.settingsManager.rSetting(phaseSpeed = new Setting("PhaseSpeed", this, .0424, .01, .0700, false, "PhaseSpeed", true));
        CousinWare.INSTANCE.settingsManager.rSetting(phaseCheck = new Setting("PhaseCheck", this, true, "PhaseWalkPhaseCheck", true));
        CousinWare.INSTANCE.settingsManager.rSetting(downOnShift = new Setting("DownOnShift", this, true, "PhaseWalkDownOnShift", true));
        CousinWare.INSTANCE.settingsManager.rSetting(stopMotion = new Setting("StopMotion", this, true, "PhaseWalkStopMotion", true));
        CousinWare.INSTANCE.settingsManager.rSetting(stopMotionDelay = new Setting("StopMotionDelay", this, 5, 0, 20, true, "PhaseWalkStopMotionDelay", stopMotion.getValBoolean()));
    }
//
    public void onUpdate() {
            delay++;
            if (mc.gameSettings.keyBindForward.isKeyDown() || mc.gameSettings.keyBindRight.isKeyDown() || mc.gameSettings.keyBindLeft.isKeyDown() || mc.gameSettings.keyBindBack.isKeyDown() || mc.gameSettings.keyBindSneak.isKeyDown()) {
               if (phaseCheck.getValBoolean() && !eChestCheck() && !mc.world.getBlockState(PlayerUtil.getPlayerPos()).getBlock().equals(Blocks.AIR) || !mc.world.getBlockState(PlayerUtil.getPlayerPos().up()).getBlock().equals(Blocks.AIR)) {
                   if (mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isPressed() && mc.player.isSneaking()) {
                       double[] dirSpeed = this.getMotion(phaseSpeed.getValDouble());
                       if (downOnShift.getValBoolean() && mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isKeyDown())mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX + dirSpeed[0], mc.player.posY - .0424, mc.player.posZ + dirSpeed[1], mc.player.rotationYaw, mc.player.rotationPitch, false));
                       else mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX + dirSpeed[0], mc.player.posY, mc.player.posZ + dirSpeed[1], mc.player.rotationYaw, mc.player.rotationPitch, false));
                       mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX, -1337.0, mc.player.posZ, mc.player.rotationYaw * -5, mc.player.rotationPitch * -5, true));
                       if (fallPacket.getValBoolean()) mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.STOP_RIDING_JUMP));
                       if (downOnShift.getValBoolean() && mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isKeyDown()) mc.player.setPosition(mc.player.posX + dirSpeed[0], mc.player.posY - .0424, mc.player.posZ + dirSpeed[1]);
                       else mc.player.setPosition(mc.player.posX + dirSpeed[0], mc.player.posY, mc.player.posZ + dirSpeed[1]);
                       mc.player.motionZ = 0.0;
                       mc.player.motionY = 0.0;
                       mc.player.motionX = 0.0;
                       mc.player.noClip = true;
                   }
                   if (mc.player.collidedHorizontally && stopMotion.getValBoolean() ?  delay >= stopMotionDelay.getValInt() : mc.player.collidedHorizontally) {
                       double[] dirSpeed = this.getMotion(phaseSpeed.getValDouble());
                        if (downOnShift.getValBoolean() && mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isKeyDown())mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX + dirSpeed[0], mc.player.posY - .1, mc.player.posZ + dirSpeed[1], mc.player.rotationYaw, mc.player.rotationPitch, false));
                        else mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX + dirSpeed[0], mc.player.posY, mc.player.posZ + dirSpeed[1], mc.player.rotationYaw, mc.player.rotationPitch, false));
                        mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX, -1337.0, mc.player.posZ, mc.player.rotationYaw * -5, mc.player.rotationPitch * -5, true));
                        if (fallPacket.getValBoolean()) mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.STOP_RIDING_JUMP));
                        if (downOnShift.getValBoolean() && mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isKeyDown()) mc.player.setPosition(mc.player.posX + dirSpeed[0], mc.player.posY - .1, mc.player.posZ + dirSpeed[1]); //
                        else mc.player.setPosition(mc.player.posX + dirSpeed[0], mc.player.posY, mc.player.posZ + dirSpeed[1]);

                        mc.player.motionZ = 0.0;
                        mc.player.motionY = 0.0;
                        mc.player.motionX = 0.0;
                        mc.player.noClip = true;
                        delay = 0;
                        //
                    } else {
                        if (instantWalk.getValBoolean()) {
                            final double[] dir = MathUtil.directionSpeed(instantWalkSpeed.getValDouble());
                            mc.player.motionX = dir[0];
                            mc.player.motionZ = dir[1];
                        }

                    }
                }
            }
        }

    public void onEnable() {

    }

    private double[] getMotion(double speed) {
        float moveForward = mc.player.movementInput.moveForward;
        float moveStrafe = mc.player.movementInput.moveStrafe;
        float rotationYaw = mc.player.prevRotationYaw + (mc.player.rotationYaw - mc.player.prevRotationYaw) * mc.getRenderPartialTicks();
        if (moveForward != 0.0f) {
            if (moveStrafe > 0.0f) {
                rotationYaw += (float)(moveForward > 0.0f ? -45 : 45);
            } else if (moveStrafe < 0.0f) {
                rotationYaw += (float)(moveForward > 0.0f ? 45 : -45);
            }
            moveStrafe = 0.0f;
            if (moveForward > 0.0f) {
                moveForward = 1.0f;
            } else if (moveForward < 0.0f) {
                moveForward = -1.0f;
            }
        }
        double posX = (double)moveForward * speed * -Math.sin(Math.toRadians(rotationYaw)) + (double)moveStrafe * speed * Math.cos(Math.toRadians(rotationYaw));
        double posZ = (double)moveForward * speed * Math.cos(Math.toRadians(rotationYaw)) - (double)moveStrafe * speed * -Math.sin(Math.toRadians(rotationYaw));
        return new double[]{posX, posZ};
    }

    public void onDisable() {
        mc.player.noClip = false;


    }

    private boolean eChestCheck() {
        String loc = String.valueOf(mc.player.posY);
        String deciaml = loc.split("\\.")[1];
        return deciaml.equals("875");
    }
    //
}
